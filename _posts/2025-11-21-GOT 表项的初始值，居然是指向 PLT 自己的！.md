---
layout: post
title: "GOT 表项的初始值，居然是指向 PLT 自己的！"
date: 2024-06-12
categories: [Linux]
---


### 1. 静态视角：内存里长什么样？

假设我们编译了一个程序，里面调用了 `printf`。

#### A. 代码段 (`.text`)
这是你写的代码编译后的样子。
```assembly
0x401000: call 0x401020  <printf@plt>  ; 这里的地址是 PLT 表的地址
```

#### B. PLT 表 (`.plt` 代码)
这是编译器生成的跳板代码。每个外部函数都有一小块（PLT条目）。
```assembly
; printf 的 PLT 条目
0x401020: jmp *0x404008  <printf@got.plt> ; 【关键指令1】跳到 GOT 表指定的地址去
0x401026: push 0x0                        ; 压入 printf 的编号（ID）
0x40102b: jmp 0x401010                    ; 跳到 PLT[0]（去叫解析器）
```

#### C. GOT 表 (`.got.plt` 数据)
这是一个数组，存地址指针的。
**注意：** 在程序刚加载、还没运行到 `printf` 之前，这里的值是编译器填好的。

| 内存地址 | 变量名 | **初始值 (这是关键!)** |
| :--- | :--- | :--- |
| 0x404008 | `printf@got` | **0x401026** |

**看到诡计了吗？**
GOT 表里 `0x404008` 这个位置，存的值竟然是 `0x401026`。
而 `0x401026` 正是 PLT 表中 `jmp` 指令的**下一行**（`push 0x0`）的地址。

---

### 2. 动态视角：第一次调用（慢速解析）

让我们逐行执行代码，看看 CPU 发生了什么：

1.  **主程序调用**：
    CPU 执行 `call 0x401020`。
    -> **结果**：程序跳转到了 PLT 表的 `0x401020`。

2.  **PLT 第一跳**：
    CPU 执行 `0x401020: jmp *0x404008`。
    意思是：取出 `0x404008` 里的值，把它作为目标地址跳过去。
    此刻，GOT 里存的值是 `0x401026`。
    -> **结果**：程序跳到了 `0x401026`。
    *(你发现了吗？程序只是象征性地去 GOT 兜了一圈，又被踢回了 PLT 表的下一行！这就是为了判断“是不是第一次”)*

3.  **准备参数**：
    CPU 执行 `0x401026: push 0x0`。
    -> **结果**：告诉动态链接器，我要找的是第 0 号函数（即 printf）。

4.  **呼叫链接器**：
    CPU 执行 `0x40102b: jmp 0x401010`。
    这是 PLT 的公共条目，它最终会调用系统的动态链接器函数 `_dl_runtime_resolve`。

5.  **链接器工作（Magic happens here）**：
    链接器去 `libc.so` 里找到了 `printf` 的**真实内存地址**（假设是 `0x7ffff7a62800`）。
    **最重要的一步来了：链接器会修改 GOT 表！**
    它把 `0x404008` 里的那个旧值 `0x401026` 抹掉，填入真实的 `0x7ffff7a62800`。

6.  **执行函数**：
    链接器把控制权交给 `printf`。

---

### 3. 动态视角：第二次调用（快速直达）

现在 GOT 表变了：

| 内存地址 | 变量名 | **当前值 (已修改)** |
| :--- | :--- | :--- |
| 0x404008 | `printf@got` | **0x7ffff7a62800** (真实地址) |

让我们再次逐行执行：

1.  **主程序调用**：
    CPU 执行 `call 0x401020`（还是跳到 PLT）。

2.  **PLT 第一跳**：
    CPU 执行 `0x401020: jmp *0x404008`。
    意思是：取出 `0x404008` 里的值跳过去。
    这次取出的值是 `0x7ffff7a62800`。

3.  **直达**：
    -> **结果**：CPU 直接飞到了 `libc.so` 里的 `printf` 函数代码处开始执行。
    后面的 `push 0x0` 和 `jmp resolver` 根本不会被执行到。

---

### 总结这一套“细节”

1.  **间接跳转**：PLT 不直接跳函数，而是跳 `*GOT`（去读 GOT 里的地址）。
2.  **回环诡计**：编译器生成文件时，故意把 GOT 里的值填成“PLT 的下一行代码”。
3.  **懒加载逻辑**：
    *   如果是**旧值**（指向 PLT 内部）：说明没解析过，继续往下走，去触发解析逻辑。
    *   如果是**新值**（指向 libc 外部）：说明解析过了，直接飞走，不再回来。

这就是所谓的“细节”：**利用 GOT 表数据的覆写，改变了代码的执行流向。**

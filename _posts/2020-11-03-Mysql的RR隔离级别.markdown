---
layout: post
title: "Mysql的RR隔离级别"
date: 2020-11-03
categories: [Linux]
---

> 

## ReadView

`ReadView`会对数据在每个时刻的状态拍成照片记录下来。那么之后获取某时刻的数据时就还是原来的照片上的数据，是不会变的。其实也可以简单理解为是一个版本链的集合，只不过在这里的版本链是经过筛选的。

* `m_ids` 表示在生成READVIEW时当前系统中活跃的读写事务的事务id列表，活跃的是指当前系统中那些尚未提交的事务；
* `min_trx_id` 表示在生成READVIEW时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值；
* `max_trx_id` 表示生成READVIEW时系统中应该分配给下一个事务的事务id值，由于事务id一般是递增分配的，所以max_trx_id就是m_ids中最大的那个id再加上1；
* `creator_trx_id` 表示生成该READVIEW的事务id，由于只有在对表中记录做改动（增删改）时才会为事务分配事务id，所以在一个读取数据的事务中的事务id默认为0；

## 原理

基于ReadView机制可以实现RC隔离级别，即每次查询的时候都生成一个ReadView，这样的话，只要在这次查询之前有别的事务提交了（ m_ids 列表发生变换），那么别的事务更新的数据，是可以看到的。
那么如果是RR级别呢？RR级别下，这个事务读一条数据，无论读多少次，都是一个值，别的事务修改数据之后哪怕提交了，也是看不到人家修改的值的，这就避免了不可重复读的问题。同时如果别的事务插入了一些新的数据，也是读不到的，这样就可以避免幻读的问题。

* 首先假设有一条数据是事务id=50的一个事务插入的，同时此时有事务A和事务B同时在运行，事务A的id是60，事务B的id是70

* 这个时候，事务A发起了一个查询，它就是第一次查询就会生成一个ReadView，此时ReadView里的creator_trx_id是60，min_trx_id是60，max_trx_id是71，m_ids是[60, 70]

* 这个时候事务A基于这个ReadView去查这条数据，会发现这条数据的trx_id为50，是小于ReadView里的min_trx_id的，说明它发起查询之前，早就有事务插入这条数据还提交了，所以此时可以查到这条原始值的

* 接着就是事务B此时更新了这条数据的值为值B，此时会修改trx_id为70，同时生成一个undo log，而且关键是事务B此时它还提交了，也就是说此时事务B已经结束了

* 事务A去查询这条数据的值，会惊讶的发现此时数据的trx_id是70了，因为在RR级别，ReadView不会改变，根据ReadView的读取规则可以知道事务A不能查到txr_id=70对应的数据，而是会顺着undo指针找到原始值，所以事务A在事务B修改数据的前后读取的数据是一样的

